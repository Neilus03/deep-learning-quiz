<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Deep Learning Questions</title>
<style>
  button {
    margin: 5px;
  }
</style>
<script>
  const questions = [
  {
    question: "1.1 A feedforward neural network with a single hidden layer and a sufficient number of hidden neurons can approximate any continuous function.",
    answer: "True"
  },
  {
    question: "1.2 Leaky ReLU activation functions are more likely to suffer from the vanishing gradient problem compared to sigmoid activation functions.",
    answer: "False"
  },
  {
    question: "1.3 Gradient clipping is a technique used to prevent the exploding gradient problem in deep learning.",
    answer: "True"
  },
  {
    question: "2.1 The Nesterov Accelerated Gradient (NAG) optimization algorithm is an extension of momentum that incorporates the gradient's future position.",
    answer: "True"
  },
  {
    question: "2.2 The RMSProp optimization algorithm is specifically designed to resolve the diminishing learning rates problem in the AdaGrad algorithm.",
    answer: "True"
  },
  {
    question: "2.3 Weight decay is a form of L1 regularization that adds a penalty term to the loss function, discouraging large weight values and promoting sparsity.",
    answer: "False"
  },
  {
    question: "3.1 The Gated Recurrent Unit (GRU) is a simplified version of the LSTM, with fewer parameters and a more efficient training process.",
    answer: "True"
  },
  {
    question: "3.2 In RNNs, the vanishing gradient problem can be alleviated by implementing techniques such as Long Short-Term Memory (LSTM) or Gated Recurrent Unit (GRU) layers.",
    answer: "True"
  },
  {
    question: "3.3 Bidirectional RNNs process input sequences in both forward and backward directions, enabling the model to better capture long-range dependencies.",
    answer: "True"
  },
  {
    question: "4.1 Dropout is a regularization technique that involves setting a random fraction of input units to zero during training to prevent overfitting.",
    answer: "True"
  },
  {
    question: "4.2 Data augmentation is a technique used to artificially increase the size of the training dataset by applying various transformations to the original data.",
    answer: "True"
  },
  {
    question: "4.3 A learning rate scheduler is a technique used to adjust the learning rate during training, usually increasing it as the number of training iterations increases.",
    answer: "False"
  },
  {
    question: "5.1 Convolutional Neural Networks (CNNs) employ weight sharing, which reduces the number of parameters in the model, making it more efficient to train.",
    answer: "True"
  },
  {
    question: "5.2 The use of dilated convolutions in a CNN architecture allows the model to have a larger receptive field without increasing the number of parameters significantly.",
    answer: "True"
  },
  {
    question: "5.3 The transformer architecture, which relies on self-attention mechanisms, has become the foundation for many state-of-the-art natural language processing models.",
    answer: "True"
  }
];


  function renderQuestions() {
    questions.forEach((question, index) => {
      const div = document.createElement('div');
      const p = document.createElement('p');
      p.textContent = `${index + 1}. ${question.question}`;
      div.appendChild(p);

      const trueButton = document.createElement('button');
      trueButton.textContent = 'True';
      trueButton.onclick = () => checkAnswer(index, trueButton, falseButton, true);
      div.appendChild(trueButton);

      const falseButton = document.createElement('button');
      falseButton.textContent = 'False';
      falseButton.onclick = () => checkAnswer(index, trueButton, falseButton, false);
      div.appendChild(falseButton);

      document.body.appendChild(div);
    });
  }

  function checkAnswer(questionIndex, trueButton, falseButton, userAnswer) {
    const correctAnswer = questions[questionIndex].answer === 'True';
    const selectedButton = userAnswer ? trueButton : falseButton;
    const otherButton = userAnswer ? falseButton : trueButton;

    if (correctAnswer === userAnswer) {
      selectedButton.style.backgroundColor = 'green';
    } else {
      selectedButton.style.backgroundColor = 'red';
    }

    // Disable buttons after the user has made a choice
    trueButton.disabled = true;
    falseButton.disabled = true;
  }

  document.addEventListener("DOMContentLoaded", renderQuestions);
</script>
</head>
<body>
</body>
</html>
